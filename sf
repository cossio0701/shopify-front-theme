#!/bin/bash

# sf - Shopify Flow CLI para gestionar cambios entre Git y Shopify Admin
# Versi√≥n: 1.0
# Autor: Asistente de desarrollo

# Variables globales
SHOPIFY_STORE="${SHOPIFY_STORE:-}"
SHOPIFY_THEME_ID="${SHOPIFY_THEME_ID:-}"
CURRENT_BRANCH=""
HISTORY_FILE=".sf_history"

# Funci√≥n para cargar variables de entorno desde .env
load_env() {
    local env_file=".env"
    if [[ -f "$env_file" ]]; then
        source "$env_file"
    fi
}

# Funci√≥n para registrar acciones en el historial
log_history() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] $message" >> "$HISTORY_FILE"
}

# Funci√≥n para validar dependencias
validate_dependencies() {
    local missing_deps=()

    # Verificar Git
    if ! command -v git &> /dev/null; then
        missing_deps+=("Git")
    fi

    # Verificar Shopify CLI
    if ! command -v shopify &> /dev/null; then
        missing_deps+=("Shopify CLI")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "‚ùå Error: Las siguientes dependencias no est√°n instaladas:"
        printf "  - %s\n" "${missing_deps[@]}"
        echo ""
        echo "Instala las dependencias faltantes:"
        echo "  - Git: https://git-scm.com/downloads"
        echo "  - Shopify CLI: https://shopify.dev/themes/tools/cli"
        exit 1
    fi
}

# Funci√≥n para parsear flags globales
parse_flags() {
    local dry_run=false
    local force=false
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                dry_run=true
                shift
                ;;
            --force)
                force=true
                shift
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Devolver los valores parseados
    echo "$dry_run $force $verbose"
}

# Funci√≥n para validar variables de entorno
validate_env() {
    if [[ -z "$SHOPIFY_STORE" || -z "$SHOPIFY_THEME_ID" ]]; then
        echo "‚ùå Error: Variables de entorno no configuradas"
        echo ""
        echo "Soluci√≥n:"
        echo "1. Crea o edita el archivo .env en la ra√≠z del proyecto:"
        echo "   SHOPIFY_STORE=\"tu-tienda.myshopify.com\""
        echo "   SHOPIFY_THEME_ID=\"123456789\""
        echo ""
        echo "2. O configura las variables en tu entorno:"
        echo "   export SHOPIFY_STORE=\"tu-tienda.myshopify.com\""
        echo "   export SHOPIFY_THEME_ID=\"123456789\""
        echo ""
        echo "Despu√©s de configurar, ejecuta el comando nuevamente."
        exit 1
    fi

    # Validar formato b√°sico
    if [[ ! "$SHOPIFY_STORE" =~ \.myshopify\.com$ ]]; then
        echo "‚ö†Ô∏è  Advertencia: SHOPIFY_STORE no parece una URL de Shopify v√°lida"
        echo "   Esperado: algo.myshopify.com"
        echo "   Actual: $SHOPIFY_STORE"
    fi

    if [[ ! "$SHOPIFY_THEME_ID" =~ ^[0-9]+$ ]]; then
        echo "‚ö†Ô∏è  Advertencia: SHOPIFY_THEME_ID debe ser un n√∫mero"
        echo "   Actual: $SHOPIFY_THEME_ID"
    fi
}

# Funci√≥n para verificar si la terminal soporta colores
supports_colors() {
    # Forzar colores ANSI siempre
    return 0
}

# Funci√≥n para colorear texto si es soportado
color_text() {
    local color_code="$1"
    local text="$2"

    if supports_colors; then
        echo -e "\033[${color_code}m${text}\033[0m"
    else
        # Si no hay colores, usar may√∫sculas y s√≠mbolos para resaltar
        case "$color_code" in
            "1;31") echo "‚ùå $text" ;;  # Rojo -> Error symbol
            "1;32") echo "‚úÖ $text" ;;  # Verde -> Success symbol
            "1;33") echo "‚ö†Ô∏è  $text" ;;  # Amarillo -> Warning symbol
            "1;34") echo "‚ÑπÔ∏è  $text" ;;  # Azul -> Info symbol
            *) echo "$text" ;;
        esac
    fi
}

# Funci√≥n para confirmar acci√≥n
confirm_action() {
    local prompt="$1"
    local default="${2:-n}"  # Default a 'n' si no se especifica
    local help_text="$3"

    echo ""
    echo "‚ö†Ô∏è  $prompt"
    if [[ -n "$help_text" ]]; then
        echo "$help_text"
    fi

    local response
    read -p "¬øContinuar? (y/N): " -n 1 -r response
    echo

    if [[ "$default" == "y" ]]; then
        [[ ! "$response" =~ ^[Nn]$ ]]
    else
        [[ "$response" =~ ^[Yy]$ ]]
    fi
}

# Funci√≥n para sugerir pr√≥ximos pasos
suggest_next_steps() {
    local command="$1"
    local context="$2"

    echo ""
    echo "üí° Pr√≥ximos pasos sugeridos:"

    case "$command" in
        init)
            echo "1. Edita .env con tus credenciales de Shopify"
            echo "2. Reinicia terminal o ejecuta: source ~/.bashrc"
            echo "3. Prueba: sf status"
            ;;
        start)
            echo "1. Realiza tus cambios en el c√≥digo"
            echo "2. Confirma cambios: sf commit"
            echo "3. Publica cuando est√© listo: sf publish --dry-run"
            ;;
        commit)
            echo "1. Verifica cambios: sf diff --with-master"
            echo "2. Publica: sf publish --dry-run (primero)"
            echo "3. Publica: sf publish"
            ;;
        publish)
            echo "1. Verifica que todo funciona en Shopify"
            echo "2. Limpia rama: sf finish"
            echo "3. Inicia nuevo trabajo: sf start"
            ;;
        sync)
            echo "1. Verifica cambios: sf status"
            echo "2. Si hay conflictos, resu√©lvelos y confirma: sf resolve"
            echo "3. Inicia nuevo trabajo: sf start"
            ;;
        resolve)
            echo "1. Verifica que todo funciona: sf status"
            echo "2. Inicia nuevo trabajo: sf start"
            ;;
        finish)
            echo "1. Verifica que todo est√° bien: sf status"
            echo "2. Inicia nuevo trabajo: sf start"
            echo "3. O sincroniza si es necesario: sf sync"
            ;;
        *)
            echo "Ejecuta 'sf help' para ver todos los comandos disponibles"
            ;;
    esac
}

# Funci√≥n para resolver conflictos con cambios de Shopify
resolve_shopify_conflicts() {
    local conflicted_files=("$@")
    if [[ ${#conflicted_files[@]} -gt 0 ]]; then
        echo "$(color_text "1;31" "‚ö†Ô∏è  Se detectaron conflictos con cambios committed. Creando marcadores de merge granulares...")"
        for file in "${conflicted_files[@]}"; do
            local base_file=$(mktemp)
            local ours_file=$(mktemp)
            local theirs_file=$(mktemp)
            echo "" > "$base_file"
            git show HEAD:"$file" > "$ours_file" 2>/dev/null || echo "" > "$ours_file"
            cat "$file" > "$theirs_file"
            git merge-file "$ours_file" "$base_file" "$theirs_file" >/dev/null 2>&1
            cat "$ours_file" > "$file"
            rm "$base_file" "$ours_file" "$theirs_file"
        done
        echo "‚úÖ Marcadores de merge granulares creados en ${#conflicted_files[@]} archivo(s)."
        echo "üîß Resuelve los conflictos editando los archivos, luego:"
        echo "  git add <archivo>"
        echo "  git commit -m 'resolve: conflictos sync Shopify'"
        return 1
    fi
    return 0
}

# Funci√≥n para verificar cambios sin commit
check_uncommitted_changes() {
    if ! git diff --quiet || ! git diff --staged --quiet; then
        echo "‚ùå Error: Hay cambios sin confirmar (commit)"
        echo ""
        echo "Archivos modificados:"
        git status --porcelain | head -10
        echo ""
        echo "Opciones:"
        echo "1. Confirma los cambios: sf commit"
        echo "2. Guarda temporalmente: sf stash"
        echo "3. Descarta cambios: git checkout -- .  (‚ö†Ô∏è  PELIGROSO)"
        echo "4. Continua de todas formas: usa --force"
        exit 1
    fi
}

# Funci√≥n para validaciones preventivas inteligentes
preventive_checks() {
    local command="$1"

    # Solo ejecutar para comandos que modifican estado
    case "$command" in
        start|commit|publish|finish|resolve)
            # Verificar si estamos en un repo Git
            if [[ ! -d ".git" ]]; then
                echo "‚ùå Error: No est√°s en un repositorio Git."
                echo "üí° Ejecuta 'sf init' para inicializar el proyecto."
                return 1
            fi

            # Verificar conexi√≥n con remoto
            if ! git ls-remote --exit-code origin >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  No se puede conectar con el repositorio remoto."
                echo "   Verifica tu conexi√≥n a internet y configuraci√≥n de Git."
            fi
            ;;
    esac

    return 0
}

# Funci√≥n para detectar y sugerir correcciones comunes
smart_suggestions() {
    local command="$1"

    case "$command" in
        start)
            # Si hay stash, sugerir restaurarlo
            if [[ $(git stash list | wc -l) -gt 0 ]]; then
                echo "üí° Tienes $(git stash list | wc -l) cambios en stash. Considera restaurarlos: git stash pop"
            fi
            ;;
        commit)
            # Si no hay cambios, sugerir qu√© hacer
            if git diff --quiet && git diff --staged --quiet; then
                echo "üí° No hay cambios para confirmar. Modifica archivos primero."
                return
            fi
            ;;
        publish)
            # Verificar si hay muchos commits sin publicar
            local commits_ahead=$(git rev-list master..HEAD --count 2>/dev/null || echo "0")
            if [[ $commits_ahead -gt 5 ]]; then
                echo "‚ö†Ô∏è  Tienes $commits_ahead commits por publicar. Considera hacer commits m√°s peque√±os."
            fi
            ;;
    esac
}

# Funci√≥n para obtener rama actual
get_current_branch() {
    CURRENT_BRANCH=$(git branch --show-current)
}

# Funci√≥n para men√∫ interactivo con flechas
interactive_menu() {
    local options=("fix:Correcci√≥n de errores" "feat:Nueva funcionalidad" "hotfix:Correcci√≥n urgente en producci√≥n" "refactor:Refactorizaci√≥n de c√≥digo" "docs:Cambios en documentaci√≥n" "style:Cambios de estilo/formato" "test:Cambios en tests" "chore:Tareas de mantenimiento")
    local selected=0
    local key=""

    # Funci√≥n para dibujar el men√∫
    draw_menu() {
        echo -e "\nSelecciona el tipo de flujo (usa ‚Üë‚Üì flechas, Enter para seleccionar):"
        for i in "${!options[@]}"; do
            if [[ $i -eq $selected ]]; then
                echo -e "  \e[7m${options[$i]}\e[0m"  # Resaltado inverso
            else
                echo "  ${options[$i]}"
            fi
        done
        echo
    }

    # Ocultar cursor
    echo -e "\e[?25l"

    # Bucle principal
    while true; do
        draw_menu
        read -sn1 key

        case "$key" in
            $'\e')  # Escape sequence
                read -sn2 -t 0.1 key2
                case "$key2" in
                    '[A')  # Flecha arriba
                        ((selected--))
                        if [[ $selected -lt 0 ]]; then
                            selected=$((${#options[@]} - 1))
                        fi
                        ;;
                    '[B')  # Flecha abajo
                        ((selected++))
                        if [[ $selected -ge ${#options[@]} ]]; then
                            selected=0
                        fi
                        ;;
                esac
                ;;
            '')  # Enter
                break
                ;;
            'q'|'Q')  # Salir con q
                echo -e "\e[?25h"  # Mostrar cursor
                echo "üö´ Operaci√≥n cancelada."
                return 1
                ;;
        esac

        # Limpiar pantalla hacia arriba
        echo -e "\e[${#options[@]}A\e[J"
    done

    # Mostrar cursor
    echo -e "\e[?25h"

    # Extraer el tipo del option seleccionado
    local selected_option="${options[$selected]}"
    flow_type="${selected_option%%:*}"
    
    echo "‚úÖ Seleccionado: $flow_type"
}

# Comando: sf start
start_branch() {
    validate_env
    echo "üöÄ Iniciando nuevo flujo de trabajo..."

    # Detectar estado actual
    echo "üìä Estado actual del proyecto:"
    detect_project_state

    get_current_branch

    # Validaciones preventivas
    if [[ "$CURRENT_BRANCH" != "master" ]]; then
        echo ""
        echo "‚ö†Ô∏è  Ya est√°s en una rama de trabajo: $CURRENT_BRANCH"
        echo "¬øQuieres continuar en esta rama o crear una nueva?"
        echo "1. Continuar en $CURRENT_BRANCH"
        echo "2. Crear nueva rama (cambiar√° a master primero)"
        echo "3. Cancelar"

        local choice
        read -p "Elige opci√≥n (1-3): " -n 1 -r choice
        echo

        case $choice in
            1)
                echo "‚úÖ Continuando en rama actual: $CURRENT_BRANCH"
                suggest_next_steps "start" "existing-branch"
                return 0
                ;;
            2)
                echo "üîÑ Cambiando a master para crear nueva rama..."
                git checkout master || { echo "‚ùå Error: No se pudo cambiar a master."; return 1; }
                ;;
            *)
                echo "üö´ Operaci√≥n cancelada."
                return 1
                ;;
        esac
    fi

    # Verificar cambios sin commit antes de crear rama
    if ! git diff --quiet || ! git diff --staged --quiet; then
        echo ""
        echo "‚ö†Ô∏è  Hay cambios sin commit en master."
        if ! confirm_action "¬øCrear rama desde este estado?" "n" "Los cambios sin commit estar√°n en la nueva rama."; then
            echo "üí° Sugerencias:"
            echo "  - Confirma cambios: sf commit"
            echo "  - Guarda temporalmente: sf stash"
            return 1
        fi
    fi

    # Sincronizar con Shopify y remoto antes de crear rama
    echo "üîÑ Sincronizando con Shopify y remoto..."
    sync_changes --force || { echo "‚ùå Error: Fall√≥ sincronizaci√≥n."; return 1; }

    # Men√∫ interactivo para seleccionar tipo de flujo
    if ! interactive_menu; then
        return 1
    fi

    # Preguntar nombre descriptivo en kebab-case
    read -p "Nombre descriptivo (kebab-case): " name
    if [[ -z "$name" ]]; then
        echo "‚ùå Error: El nombre es obligatorio."
        return 1
    fi

    if [[ ! "$name" =~ ^[a-z0-9-]+(-[a-z0-9-]+)*$ ]]; then
        echo "‚ùå Error: Nombre debe estar en kebab-case (solo letras min√∫sculas, n√∫meros y guiones)."
        echo "Ejemplos v√°lidos: add-product-slider, fix-header-bug, update-styles"
        return 1
    fi

    # Generar nombre de rama
    local date_suffix=$(date '+%Y%m%d')
    local branch_name="${flow_type}/${name}-${date_suffix}"

    echo "üìù Creando rama: $branch_name"

    # Ejecutar comandos
    git checkout -b "$branch_name" || { echo "‚ùå Error: No se pudo crear la rama."; return 1; }
    shopify theme pull -s "$SHOPIFY_STORE" -t "$SHOPIFY_THEME_ID" || { echo "‚ùå Error: Fall√≥ shopify theme pull."; return 1; }
    git push -u origin "$branch_name" || { echo "‚ùå Error: Fall√≥ git push."; return 1; }

    log_history "Started branch: $branch_name"
    echo "‚úÖ Rama '$branch_name' creada exitosamente."
    echo ""
    echo "üéØ Trabajo listo para comenzar en: $branch_name"

    suggest_next_steps "start"
}

# Funci√≥n para detectar el estado del proyecto
detect_project_state() {
    # Obtener rama actual
    local current_branch=$(git branch --show-current 2>/dev/null || echo "desconocida")

    # Contar cambios
    local staged_changes=$(git diff --staged --name-only | wc -l)
    local unstaged_changes=$(git diff --name-only | wc -l)
    local untracked_files=$(git ls-files --others --exclude-standard | wc -l)

    # Commits por publicar
    local commits_ahead=$(git rev-list origin/master..HEAD --count 2>/dev/null || git rev-list master..HEAD --count 2>/dev/null || echo "0")

    # Mostrar estado
    echo "üåø Rama actual: $(color_text "1;34" "$current_branch")"

    if [[ $staged_changes -gt 0 ]]; then
        echo "üìù Cambios preparados: $staged_changes archivo(s)"
    fi

    if [[ $unstaged_changes -gt 0 ]]; then
        echo "‚úèÔ∏è  Cambios sin preparar: $unstaged_changes archivo(s)"
    fi

    if [[ $untracked_files -gt 0 ]]; then
        echo "üìÑ Archivos no rastreados: $untracked_files archivo(s)"
    fi

    if [[ $commits_ahead -gt 0 ]]; then
        echo "‚¨ÜÔ∏è  Commits por publicar: $commits_ahead"
    fi

    # Estado general
    if [[ $staged_changes -eq 0 && $unstaged_changes -eq 0 && $untracked_files -eq 0 ]]; then
        echo "‚úÖ Repositorio limpio"
    fi
}

# Funci√≥n para validar formato de conventional commits
validate_commit_message() {
    local message="$1"

    # Tipos de commit v√°lidos (conventional commits)
    local valid_types="feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert"

    # Patr√≥n regex para conventional commits
    # Formato: type(scope): description
    # O: type: description
    local pattern="^($valid_types)(\([a-zA-Z0-9_-]+\))?: .+"

    if [[ $message =~ $pattern ]]; then
        return 0  # V√°lido
    else
        return 1  # Inv√°lido
    fi
}

# Funci√≥n para sugerir tipos de commit basados en cambios
suggest_commit_type() {
    local changes_summary="$1"

    # Analizar cambios para sugerir tipo
    if echo "$changes_summary" | grep -q "\.md\|\.txt\|README\|docs/"; then
        echo "docs"
    elif echo "$changes_summary" | grep -q "\.test\.|\.spec\.|test/|spec/"; then
        echo "test"
    elif echo "$changes_summary" | grep -q "\.css\|\.scss\|\.sass\|styles/"; then
        echo "style"
    elif echo "$changes_summary" | grep -q "package\.json\|yarn\.lock\|package-lock\.json\|\.gitignore"; then
        echo "chore"
    elif echo "$changes_summary" | grep -q "refactor\|rename\|move"; then
        echo "refactor"
    elif echo "$changes_summary" | grep -q "fix\|bug\|error\|issue"; then
        echo "fix"
    else
        echo "feat"  # Default
    fi
}

# Funci√≥n para mostrar ejemplos de conventional commits
show_commit_examples() {
    echo "üí° Formato recomendado (Conventional Commits):"
    echo ""
    echo "  feat: agregar nueva funcionalidad de login"
    echo "  fix: corregir error en validaci√≥n de email"
    echo "  docs: actualizar documentaci√≥n de instalaci√≥n"
    echo "  style: formatear c√≥digo con prettier"
    echo "  refactor: renombrar variables para mayor claridad"
    echo "  test: agregar pruebas para componente header"
    echo "  chore: actualizar dependencias"
    echo "  perf: optimizar carga de im√°genes"
    echo ""
    echo "üìù Tipos disponibles: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"
}

# Comando: sf commit
commit_changes() {
    validate_env
    get_current_branch

    if [[ "$CURRENT_BRANCH" == "master" ]]; then
        echo "‚ùå Error: No puedes hacer commit en la rama master."
        echo "üí° Usa 'sf start' para crear una rama de trabajo."
        return 1
    fi

    echo "üìù Preparando commit en rama: $CURRENT_BRANCH"

    # Mostrar estado actual
    echo "üìä Archivos modificados:"
    git status --porcelain
    echo ""

    # Verificar si hay cambios
    if git diff --quiet && git diff --staged --quiet; then
        echo "‚ö†Ô∏è  No hay cambios para confirmar."
        echo "üí° Modifica algunos archivos primero, luego ejecuta 'sf commit'."
        return 1
    fi

    # Agregar archivos
    git add . || { echo "‚ùå Error: Fall√≥ git add."; return 1; }

    # Mostrar diff resumido
    echo "üìã Cambios a confirmar:"
    git diff --staged --stat
    echo ""

    # Preguntar mensaje de commit
    echo "üìù Mensaje de commit (formato recomendado: tipo: descripci√≥n)"
    echo "üí° Presiona Enter sin escribir para ver ejemplos de tipos"

    read -p "Mensaje de commit: " commit_message

    # Si no escribe nada, mostrar ejemplos
    if [[ -z "$commit_message" ]]; then
        show_commit_examples
        echo ""
        read -p "Mensaje de commit: " commit_message
        if [[ -z "$commit_message" ]]; then
            echo "‚ùå Error: El mensaje de commit es obligatorio."
            return 1
        fi
    fi

    # Validar formato conventional commits
    if ! validate_commit_message "$commit_message"; then
        echo "‚ö†Ô∏è  El mensaje no sigue el formato recomendado de Conventional Commits."
        echo ""
        show_commit_examples
        echo ""

        # Sugerir tipo basado en cambios
        local changes_summary=$(git diff --staged --name-only)
        local suggested_type=$(suggest_commit_type "$changes_summary")
        echo "üí° Sugerencia basada en tus cambios: $suggested_type: $commit_message"
        echo ""

        if ! confirm_action "¬øUsar este mensaje de todas formas?" "n" "Se recomienda usar el formato tipo: descripci√≥n"; then
            echo "üí° Intenta con: $suggested_type: $commit_message"
            return 1
        fi
    fi

    # Validar longitud del mensaje (solo si no es conventional commit v√°lido)
    if [[ ${#commit_message} -lt 10 ]]; then
        echo "‚ö†Ô∏è  El mensaje es muy corto (${#commit_message} caracteres)."
        if ! confirm_action "¬øUsar este mensaje de todas formas?" "n"; then
            return 1
        fi
    fi

    git commit -m "$commit_message" || { echo "‚ùå Error: Fall√≥ git commit."; return 1; }

    log_history "Committed changes on $CURRENT_BRANCH: $commit_message"
    echo "‚úÖ Commit realizado exitosamente."
    echo "üíæ Mensaje: $commit_message"

    suggest_next_steps "commit"
}

# Comando: sf publish
publish_changes() {
    validate_env
    get_current_branch

    # Parsear flags
    local flags_output=$(parse_flags "$@")
    local dry_run=$(echo "$flags_output" | cut -d' ' -f1)
    local force=$(echo "$flags_output" | cut -d' ' -f2)
    local verbose=$(echo "$flags_output" | cut -d' ' -f3)

    if [[ "$CURRENT_BRANCH" == "master" ]]; then
        echo "‚ùå Error: Ya est√°s en master. Usa 'sf sync' para sincronizar."
        return 1
    fi

    echo "üöÄ Preparando publicaci√≥n de: $CURRENT_BRANCH"

    # Mostrar resumen de cambios
    echo "üìä Resumen de cambios:"
    echo "Rama: $CURRENT_BRANCH"
    echo "Commits por fusionar: $(git rev-list master.."$CURRENT_BRANCH" --count)"
    echo ""
    echo "Archivos modificados:"
    git diff --stat master.."$CURRENT_BRANCH"
    echo ""

    if [[ "$dry_run" == true ]]; then
        echo "üîç Modo dry-run: Simulando publicaci√≥n..."
        echo "  ‚úÖ Verificar que no hay conflictos"
        echo "  ‚úÖ Cambiar a master"
        echo "  ‚úÖ Fusionar $CURRENT_BRANCH"
        echo "  ‚úÖ Publicar en Shopify"
        echo "  ‚úÖ Subir cambios a remoto"
        echo ""
        echo "üí° Ejecuta sin --dry-run cuando est√©s listo para publicar."
        return 0
    fi

    # Validaciones cr√≠ticas
    if [[ "$force" != true ]]; then
        check_uncommitted_changes

        # Verificar conflictos potenciales
        echo "üîç Verificando conflictos potenciales..."
        if ! git merge-tree $(git merge-base master "$CURRENT_BRANCH") master "$CURRENT_BRANCH" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Posibles conflictos detectados."
            if ! confirm_action "¬øContinuar de todas formas?" "n" "Revisa los archivos que podr√≠an tener conflictos."; then
                return 1
            fi
        fi
    fi

    # Ejecutar sync antes de publicar para actualizar y resolver conflictos
    echo "üîÑ Ejecutando sincronizaci√≥n completa antes de publicar..."
    if ! sync_changes --force; then
        echo "‚ùå Error: Fall√≥ la sincronizaci√≥n. No se puede continuar con la publicaci√≥n."
        return 1
    fi

    # Despu√©s de sync, deber√≠amos estar en master
    echo "üöÄ Publicando cambios..."

    local feature_branch="$CURRENT_BRANCH"

    # Backup autom√°tico antes de publicar
    echo "üíæ Creando backup autom√°tico..."
    git stash push -m "backup-auto-$(date '+%Y%m%d-%H%M%S')" >/dev/null 2>&1 || true

    # Despu√©s de sync, estamos en master y listos para el merge
    if ! git merge "$feature_branch"; then
        echo "‚ùå Error: Conflicto en merge."
        echo ""
        echo "üîß Para resolver:"
        echo "1. Edita los archivos en conflicto"
        echo "2. Ejecuta: git add <archivo>"
        echo "3. Ejecuta: git commit -m 'Resolve conflicts'"
        echo "4. Luego: shopify theme push -s \"$SHOPIFY_STORE\" -t \"$SHOPIFY_THEME_ID\""
        echo "5. Finalmente: git push origin master"
        echo ""
        echo "O usa 'sf backup restore' para restaurar el estado anterior."
        exit 1
    fi

    echo "üì§ Publicando en Shopify..."
    shopify theme push -s "$SHOPIFY_STORE" -t "$SHOPIFY_THEME_ID" || {
        echo "‚ùå Error: Fall√≥ shopify theme push."
        echo "üí° El merge se complet√≥, pero fall√≥ la publicaci√≥n en Shopify."
        echo "   Puedes intentar nuevamente o publicar manualmente."
        return 1
    }

    git push origin master || { echo "‚ùå Error: Fall√≥ git push."; return 1; }

    log_history "Published changes from $feature_branch to master"
    echo "‚úÖ ¬°Publicaci√≥n completada exitosamente!"
    echo "üåê Cambios publicados en: https://$SHOPIFY_STORE"
    echo "ÔøΩ Rama fusionada: $feature_branch ‚Üí master"

    suggest_next_steps "publish"
}

# Comando: sf sync
sync_changes() {
    validate_env

    # Parsear flags
    local flags_output=$(parse_flags "$@")
    local dry_run=$(echo "$flags_output" | cut -d' ' -f1)
    local force=$(echo "$flags_output" | cut -d' ' -f2)
    local verbose=$(echo "$flags_output" | cut -d' ' -f3)

    get_current_branch

    echo "üîÑ Sincronizando con Shopify Admin..."
    echo "üìç Rama actual: $CURRENT_BRANCH"

    if [[ "$dry_run" == true ]]; then
        echo "üîç Modo dry-run: Simulando sincronizaci√≥n..."
        echo "  ‚úÖ Verificar cambios en Shopify Admin"
        echo "  ‚úÖ Cambiar a master si es necesario"
        echo "  ‚úÖ Sincronizar repositorio local"
        echo "  ‚úÖ Verificar conflictos con cambios locales"
        return 0
    fi

    # Verificar cambios locales sin commit ANTES de cualquier operaci√≥n
    local has_local_changes=false
    if ! git diff --quiet || ! git diff --staged --quiet; then
        has_local_changes=true
        echo "‚ö†Ô∏è  Tienes cambios locales sin commit."
        echo ""
        echo "üìù Archivos modificados:"
        git status --porcelain | head -10
        echo ""

        if [[ "$force" == true ]]; then
            echo "üîÑ Modo force activado: guardando cambios en stash autom√°ticamente..."
            git stash push -m "auto-stash-sync-$(date '+%Y%m%d-%H%M%S')" || { echo "‚ùå Error: Fall√≥ git stash."; return 1; }
            echo "‚úÖ Cambios guardados en stash."
        else
            echo "Opciones:"
            echo "1. Guardar cambios en stash temporalmente"
            echo "2. Confirmar cambios primero (recomendado)"
            echo "3. Cancelar sincronizaci√≥n"
            echo ""

            local choice
            read -p "Elige opci√≥n (1-3): " -n 1 -r choice
            echo

            case $choice in
                1)
                    echo "üì¶ Guardando cambios en stash..."
                    git stash push -m "auto-stash-sync-$(date '+%Y%m%d-%H%M%S')" || { echo "‚ùå Error: Fall√≥ git stash."; return 1; }
                    echo "‚úÖ Cambios guardados en stash."
                    ;;
                2)
                    echo "üí° Confirma tus cambios primero con 'sf commit', luego ejecuta 'sf sync' nuevamente."
                    return 1
                    ;;
                *)
                    echo "üö´ Sincronizaci√≥n cancelada."
                    return 1
                    ;;
            esac
        fi
    fi

    # Cambiar a master si no estamos ah√≠
    if [[ "$CURRENT_BRANCH" != "master" ]]; then
        echo "üîÑ Cambiando a rama master..."
        git checkout master || { echo "‚ùå Error: No se pudo cambiar a master."; return 1; }
    fi

    # Verificar cambios en Shopify antes de descargar
    echo "üîç Verificando cambios en Shopify Admin..."

    # Recordar estado antes del pull
    local changes_before=$(git status --porcelain | wc -l)

    # Intentar descargar cambios desde Shopify
    echo "üì• Descargando cambios desde Shopify..."
    if shopify theme pull -s "$SHOPIFY_STORE" -t "$SHOPIFY_THEME_ID" 2>/dev/null; then
        # Verificar si realmente hab√≠a cambios comparando con el estado anterior
        local changes_after=$(git status --porcelain | wc -l)
        if [[ $changes_after -gt $changes_before ]]; then
            local shopify_has_changes=true
            echo "‚úÖ Se encontraron cambios nuevos desde Shopify Admin."
            # Verificar si hay conflictos con cambios committed
            local conflicted_files=()
            for file in $(git diff --name-only); do
                if git diff HEAD "$file" >/dev/null 2>&1; then
                    conflicted_files+=("$file")
                fi
            done
            resolve_shopify_conflicts "${conflicted_files[@]}"
            if [[ $? -eq 1 ]]; then
                return 1
            fi
        else
            local shopify_has_changes=false
            echo "‚úÖ No hay cambios nuevos en Shopify Admin."
        fi
    else
        echo "‚ùå Error: Fall√≥ shopify theme pull."
        echo "üí° Verifica tu conexi√≥n y credenciales de Shopify."
        return 1
    fi

    # Sincronizar con remoto
    echo "üîÑ Sincronizando con repositorio remoto..."
    git pull origin master || {
        echo "$(color_text "1;31" "‚ùå Error: Fall√≥ git pull. Posible conflicto con cambios remotos.")"
        echo "üí° Resuelve manualmente: git pull origin master"
        return 1
    }

    # Si hab√≠a cambios locales guardados en stash, intentar restaurarlos
    if [[ "$has_local_changes" == true ]]; then
        echo "üîÑ Restaurando cambios locales desde stash..."
        if git stash pop >/dev/null 2>&1; then
            echo "‚úÖ Cambios locales restaurados exitosamente."

            # Verificar si hay conflictos despu√©s de restaurar
            if git diff --quiet && git diff --staged --quiet; then
                echo "‚úÖ No hay conflictos entre cambios locales y de Shopify."
            else
                echo "$(color_text "1;31" "‚ö†Ô∏è  Hay conflictos entre tus cambios locales y los de Shopify.")"
                echo ""
                echo "$(color_text "1;31" "üìù Archivos con conflictos:")"
                git status --porcelain | grep "^UU\|^AA\|^DD" | head -10
                echo ""
                echo "üîß Para resolver conflictos:"
                echo "1. Edita los archivos marcados con 'UU' (conflicto)"
                echo "2. Ejecuta: git add <archivo> despu√©s de resolver"
                echo "3. Confirma: git commit -m 'resolve: conflictos sync Shopify'"
                echo ""
                echo "O usa 'git merge --abort' para cancelar y restaurar estado anterior."
                return 1
            fi
        else
            echo "‚ö†Ô∏è  No se pudieron restaurar los cambios del stash."
            echo "üí° Puedes restaurarlos manualmente con: git stash pop"
        fi
    fi

    # Verificar si hay cambios despu√©s de sync (solo si no hab√≠a cambios locales originalmente)
    if [[ "$has_local_changes" == false ]] && (! git diff --quiet || ! git diff --staged --quiet); then
        echo ""
        echo "üìù Se encontraron cambios despu√©s de sincronizar:"
        git status --porcelain | head -5

        if [[ "$force" == true ]] || confirm_action "¬øConfirmar estos cambios autom√°ticamente?" "y" "Se crear√° un commit con mensaje 'sync: cambios desde admin Shopify'"; then
            git add . || { echo "‚ùå Error: Fall√≥ git add."; return 1; }
            git commit -m "sync: cambios desde admin Shopify" || { echo "‚ùå Error: Fall√≥ git commit."; return 1; }
            git push origin master || { echo "‚ùå Error: Fall√≥ git push."; return 1; }
            log_history "Synced and committed changes from Shopify Admin"
            echo "‚úÖ Sincronizaci√≥n completada con commit autom√°tico."
        else
            echo "üö´ Sincronizaci√≥n cancelada."
            echo "üí° Los cambios locales permanecen sin commit."
            echo "   Puedes confirmarlos manualmente cuando est√©s listo."
            return 1
        fi
    else
        if [[ "$shopify_has_changes" == true ]] || [[ "$has_local_changes" == true ]]; then
            log_history "Synced from Shopify Admin"
            echo "‚úÖ Sincronizaci√≥n completada. Cambios de Shopify incorporados."
        else
            log_history "Sync checked (no changes)"
            echo "‚úÖ Todo est√° sincronizado. No hay cambios nuevos."
        fi
    fi

    suggest_next_steps "sync"
}

# Comando: sf resolve
resolve_conflicts() {
    validate_env
    echo "üîß Resolviendo conflictos y confirmando cambios..."

    get_current_branch

    # Verificar que estamos en master
    if [[ "$CURRENT_BRANCH" != "master" ]]; then
        echo "‚ùå Error: Debes estar en la rama master para resolver conflictos."
        echo "üí° Cambia a master: git checkout master"
        return 1
    fi

    # Verificar que estamos en medio de un merge o hay cambios para confirmar
    if git diff --quiet && git diff --staged --quiet && ! [[ -f .git/MERGE_HEAD ]]; then
        echo "‚ÑπÔ∏è  No hay conflictos pendientes ni cambios para confirmar."
        echo ""
        echo "ÔøΩ Estado actual del repositorio:"
        detect_project_state
        echo ""
        echo "üí° Si quieres sincronizar los cambios actuales con Shopify Admin:"
        echo "   shopify theme push -s \"$SHOPIFY_STORE\" -t \"$SHOPIFY_THEME_ID\""
        echo ""
        echo "üí° O si tienes cambios en una rama de trabajo, considera:"
        echo "   sf publish  # Para publicar cambios desde una rama de trabajo"
        return 0
    fi

    # Agregar todos los cambios
    echo "üìù Agregando archivos resueltos..."
    git add . || { echo "‚ùå Error: Fall√≥ git add."; return 1; }

    # Confirmar con mensaje espec√≠fico
    local commit_message="resolve: conflictos sync Shopify"
    echo "‚úÖ Confirmando cambios con mensaje: '$commit_message'"
    git commit -m "$commit_message" || { echo "‚ùå Error: Fall√≥ git commit."; return 1; }

    # Publicar cambios
    echo "üì§ Publicando cambios a remoto..."
    git push origin master || { echo "‚ùå Error: Fall√≥ git push."; return 1; }

    log_history "Resolved conflicts and committed changes"
    echo "‚úÖ Conflictos resueltos y publicados exitosamente."

    suggest_next_steps "resolve"
}

# Comando: sf status
show_status() {
    validate_env
    echo "üìä Estado del proyecto:"

    # Usar funci√≥n de detecci√≥n de estado
    detect_project_state

    echo ""
    echo "üîó Shopify Store: $(color_text "1;32" "$SHOPIFY_STORE")"
    echo "üÜî Theme ID: $SHOPIFY_THEME_ID"
    echo ""
    echo "üí° Para verificar cambios en Shopify Admin:"
    echo "   shopify theme pull -s \"$SHOPIFY_STORE\" -t \"$SHOPIFY_THEME_ID\""
}

# Comando: sf finish
finish_branch() {
    validate_env
    get_current_branch

    if [[ "$CURRENT_BRANCH" == "master" ]]; then
        echo "‚ùå Error: No puedes finalizar la rama master."
        return 1
    fi

    echo "üßπ Preparando limpieza de rama: $CURRENT_BRANCH"

    # Verificar estado
    echo "üìä Verificando estado antes de eliminar..."

    # Verificar si la rama est√° fusionada
    if git merge-base --is-ancestor "$CURRENT_BRANCH" master 2>/dev/null; then
        echo "‚úÖ Rama fusionada en master"
    else
        echo "‚ö†Ô∏è  Rama NO fusionada en master"
        echo "üí° Aseg√∫rate de haber ejecutado 'sf publish' primero."
        if ! confirm_action "¬øEliminar rama de todas formas?" "n"; then
            return 1
        fi
    fi

    # Verificar cambios sin commit
    if ! git diff --quiet || ! git diff --staged --quiet; then
        echo "‚ö†Ô∏è  Hay cambios sin commit en esta rama."
        echo "Opciones:"
        echo "1. Guardar cambios: sf stash"
        echo "2. Forzar eliminaci√≥n (perder√°s cambios)"
        echo "3. Cancelar y hacer commit primero"

        local choice
        read -p "Elige opci√≥n (1-3): " -n 1 -r choice
        echo

        case $choice in
            1)
                echo "üì¶ Guardando cambios en stash..."
                git stash push -m "auto-stash-finish-$(date '+%Y%m%d-%H%M%S')" || {
                    echo "‚ùå Error: No se pudieron guardar los cambios."
                    return 1
                }
                ;;
            2)
                echo "‚ö†Ô∏è  Los cambios sin commit se perder√°n permanentemente."
                if ! confirm_action "¬øConfirmas eliminaci√≥n forzada?" "n"; then
                    return 1
                fi
                ;;
            *)
                echo "üö´ Operaci√≥n cancelada. Confirma o guarda tus cambios primero."
                return 1
                ;;
        esac
    fi

    local branch_to_delete="$CURRENT_BRANCH"

    if ! confirm_action "¬øConfirmas eliminar la rama '$branch_to_delete'?" "n" "Esta acci√≥n no se puede deshacer."; then
        echo "üö´ Operaci√≥n cancelada."
        return 1
    fi

    echo "üßπ Eliminando rama..."

    git checkout master || { echo "‚ùå Error: No se pudo cambiar a master."; return 1; }
    git branch -d "$branch_to_delete" || { echo "‚ùå Error: No se pudo eliminar la rama local."; return 1; }

    # Intentar eliminar rama remota
    if git push origin --delete "$branch_to_delete" 2>/dev/null; then
        echo "‚úÖ Rama remota eliminada"
    else
        echo "‚ö†Ô∏è  No se pudo eliminar rama remota (puede que no exista)"
    fi

    log_history "Finished and deleted branch: $branch_to_delete"
    echo "‚úÖ Rama '$branch_to_delete' eliminada exitosamente."
    echo "üìç Ahora est√°s en: master"

    suggest_next_steps "finish"
}

# Comando: sf stash (extra)
stash_changes() {
    read -p "Mensaje para el stash: " stash_message
    if [[ -z "$stash_message" ]]; then
        stash_message="Stashed changes"
    fi

    git stash push -m "$stash_message" || { echo "‚ùå Error: Fall√≥ git stash."; return 1; }

    log_history "Stashed changes: $stash_message"
    echo "‚úÖ Cambios guardados en stash."
}

# Comando: sf log
show_log() {
    if [[ ! -f "$HISTORY_FILE" ]]; then
        echo "üìú No hay historial de acciones registrado."
        return 0
    fi

    echo "üìú Historial de acciones de sf:"
    echo "================================="

    local filter=""
    local limit=""

    # Parsear argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            --last)
                limit="$2"
                shift 2
                ;;
            --today)
                filter="today"
                shift
                ;;
            --yesterday)
                filter="yesterday"
                shift
                ;;
            --this-week)
                filter="this-week"
                shift
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Opciones: --last N, --today, --yesterday, --this-week"
                return 1
                ;;
        esac
    done

    # Leer y filtrar historial
    local entries=()
    while IFS= read -r line; do
        local should_include=true

        if [[ -n "$filter" ]]; then
            local entry_date=$(echo "$line" | cut -d' ' -f1)
            local today=$(date '+%Y-%m-%d')
            local yesterday=$(date -d 'yesterday' '+%Y-%m-%d')

            case $filter in
                today)
                    [[ "$entry_date" != "$today" ]] && should_include=false
                    ;;
                yesterday)
                    [[ "$entry_date" != "$yesterday" ]] && should_include=false
                    ;;
                this-week)
                    local week_start=$(date -d 'last monday' '+%Y-%m-%d')
                    [[ "$entry_date" < "$week_start" ]] && should_include=false
                    ;;
            esac
        fi

        if [[ "$should_include" == true ]]; then
            entries+=("$line")
        fi
    done < "$HISTORY_FILE"

    # Aplicar l√≠mite
    if [[ -n "$limit" ]]; then
        entries=("${entries[@]: -limit}")
    fi

    # Mostrar entradas
    if [[ ${#entries[@]} -eq 0 ]]; then
        echo "No se encontraron entradas con los filtros aplicados."
    else
        for entry in "${entries[@]}"; do
            echo "$entry"
        done
    fi
}

# Comando: sf diff
show_diff() {
    validate_env
    get_current_branch

    local diff_type="master"
    local target=""

    # Parsear argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            --with-shopify)
                diff_type="shopify"
                shift
                ;;
            --with-master)
                diff_type="master"
                shift
                ;;
            --branches)
                if [[ -n "$2" && -n "$3" ]]; then
                    diff_type="branches"
                    local branch1="$2"
                    local branch2="$3"
                    shift 3
                else
                    echo "‚ùå Uso: sf diff --branches <rama1> <rama2>"
                    return 1
                fi
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Opciones:"
                echo "  --with-shopify    Comparar con cambios en Shopify Admin"
                echo "  --with-master     Comparar con rama master (por defecto)"
                echo "  --branches R1 R2  Comparar entre dos ramas espec√≠ficas"
                return 1
                ;;
        esac
    done

    echo "üîç Comparando diferencias..."

    case $diff_type in
        master)
            if [[ "$CURRENT_BRANCH" == "master" ]]; then
                echo "‚ö†Ô∏è  Ya est√°s en master. No hay diferencias que mostrar."
                return 0
            fi
            echo "Comparando $CURRENT_BRANCH con master:"
            git diff master.."$CURRENT_BRANCH"
            ;;
        shopify)
            echo "Comparando cambios locales con Shopify Admin..."
            echo "Nota: Esta es una comparaci√≥n simulada. Para ver cambios reales:"
            echo "  shopify theme pull -s \"$SHOPIFY_STORE\" -t \"$SHOPIFY_THEME_ID\""
            echo ""
            # Simular comparaci√≥n mostrando archivos modificados
            echo "Archivos que podr√≠an tener cambios en Shopify:"
            git status --porcelain | head -10
            ;;
        branches)
            echo "Comparando $branch1 con $branch2:"
            if git rev-parse --verify "$branch1" &>/dev/null && git rev-parse --verify "$branch2" &>/dev/null; then
                git diff "$branch1..$branch2"
            else
                echo "‚ùå Una o ambas ramas no existen: $branch1, $branch2"
                return 1
            fi
            ;;
    esac
}

# Comando: sf clean
clean_branches() {
    local clean_type="merged"
    local days=""
    local dry_run=false

    # Parsear argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            --merged)
                clean_type="merged"
                shift
                ;;
            --older-than)
                if [[ -n "$2" ]]; then
                    clean_type="older"
                    days="$2"
                    shift 2
                else
                    echo "‚ùå Uso: sf clean --older-than <dias>"
                    return 1
                fi
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Opciones:"
                echo "  --merged          Eliminar ramas ya merged en master"
                echo "  --older-than N    Eliminar ramas con commits m√°s antiguos que N d√≠as"
                echo "  --dry-run         Mostrar qu√© se eliminar√≠a sin hacerlo"
                return 1
                ;;
        esac
    done

    echo "üßπ Limpiando ramas..."

    local branches_to_clean=()

    case $clean_type in
        merged)
            echo "Buscando ramas ya merged en master..."
            # Obtener ramas locales merged
            while IFS= read -r branch; do
                if [[ "$branch" != "master" && "$branch" != "*" ]]; then
                    branch=${branch#* }
                    if git merge-base --is-ancestor "$branch" master 2>/dev/null; then
                        branches_to_clean+=("$branch")
                    fi
                fi
            done < <(git branch --merged master)
            ;;
        older)
            echo "Buscando ramas con commits m√°s antiguos que $days d√≠as..."
            local cutoff_date=$(date -d "$days days ago" '+%Y-%m-%d')
            while IFS= read -r branch; do
                if [[ "$branch" != "master" && "$branch" != "*" ]]; then
                    branch=${branch#* }
                    local last_commit_date=$(git log -1 --format=%ci "$branch" 2>/dev/null | cut -d' ' -f1)
                    if [[ -n "$last_commit_date" && "$last_commit_date" < "$cutoff_date" ]]; then
                        branches_to_clean+=("$branch")
                    fi
                fi
            done < <(git branch)
            ;;
    esac

    if [[ ${#branches_to_clean[@]} -eq 0 ]]; then
        echo "‚úÖ No se encontraron ramas para limpiar."
        return 0
    fi

    echo "Ramas encontradas para limpiar:"
    for branch in "${branches_to_clean[@]}"; do
        echo "  - $branch"
    done
    echo ""

    if [[ "$dry_run" == true ]]; then
        echo "üîç Modo dry-run: No se eliminaron ramas."
        return 0
    fi

    if ! confirm_action "¬øConfirmas eliminar estas ${#branches_to_clean[@]} ramas?"; then
        echo "üö´ Operaci√≥n cancelada."
        return 1
    fi

    local deleted_local=0
    local deleted_remote=0

    for branch in "${branches_to_clean[@]}"; do
        # Eliminar rama local
        if git branch -d "$branch" &>/dev/null; then
            ((deleted_local++))
            echo "  ‚úÖ Eliminada rama local: $branch"
        fi

        # Intentar eliminar rama remota
        if git push origin --delete "$branch" &>/dev/null; then
            ((deleted_remote++))
            echo "  ‚úÖ Eliminada rama remota: $branch"
        fi
    done

    log_history "Cleaned branches: ${#branches_to_clean[@]} local, $deleted_remote remote"
    echo ""
    echo "‚úÖ Limpieza completada: $deleted_local ramas locales, $deleted_remote ramas remotas eliminadas."
}

# Comando: sf backup
create_backup() {
    local backup_type="stash"
    local backup_name=""

    # Parsear argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            create)
                backup_type="stash"
                shift
                ;;
            branch)
                backup_type="branch"
                shift
                ;;
            list)
                backup_type="list"
                shift
                ;;
            restore)
                if [[ -n "$2" ]]; then
                    backup_type="restore"
                    backup_name="$2"
                    shift 2
                else
                    echo "‚ùå Uso: sf backup restore <nombre>"
                    return 1
                fi
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Opciones:"
                echo "  create              Crear backup en stash (por defecto)"
                echo "  branch              Crear backup en rama temporal"
                echo "  list                Listar backups disponibles"
                echo "  restore <nombre>    Restaurar backup espec√≠fico"
                return 1
                ;;
        esac
    done

    case $backup_type in
        stash)
            echo "üíæ Creando backup en stash..."
            local stash_message="backup-$(date '+%Y%m%d-%H%M%S')"
            git stash push -m "$stash_message" || { echo "‚ùå Error: Fall√≥ git stash."; return 1; }
            log_history "Created backup stash: $stash_message"
            echo "‚úÖ Backup creado: $stash_message"
            ;;
        branch)
            get_current_branch
            echo "üíæ Creando backup en rama temporal..."
            local backup_branch="backup/$CURRENT_BRANCH-$(date '+%Y%m%d-%H%M%S')"
            git checkout -b "$backup_branch" || { echo "‚ùå Error: No se pudo crear rama backup."; return 1; }
            git checkout "$CURRENT_BRANCH" || { echo "‚ùå Error: No se pudo volver a la rama original."; return 1; }
            log_history "Created backup branch: $backup_branch"
            echo "‚úÖ Backup creado en rama: $backup_branch"
            ;;
        list)
            echo "üìã Backups disponibles:"
            echo ""
            echo "Stashes:"
            git stash list | nl -v0 || echo "  No hay stashes"
            echo ""
            echo "Ramas de backup:"
            git branch | grep "^  backup/" | nl -v1 || echo "  No hay ramas de backup"
            ;;
        restore)
            if [[ -z "$backup_name" ]]; then
                echo "‚ùå Debes especificar el nombre del backup a restaurar."
                echo "Usa 'sf backup list' para ver backups disponibles."
                return 1
            fi

            echo "üîÑ Restaurando backup: $backup_name"

            # Intentar restaurar stash
            if git stash list | grep -q "$backup_name"; then
                local stash_index=$(git stash list | grep -n "$backup_name" | head -1 | cut -d: -f1)
                ((stash_index--))
                git stash apply "stash@{$stash_index}" || { echo "‚ùå Error: Fall√≥ restaurar stash."; return 1; }
                echo "‚úÖ Stash restaurado: $backup_name"
            # Intentar checkout de rama backup
            elif git branch | grep -q "^  $backup_name$"; then
                git checkout "$backup_name" || { echo "‚ùå Error: Fall√≥ checkout de rama backup."; return 1; }
                echo "‚úÖ Rama backup restaurada: $backup_name"
            else
                echo "‚ùå Backup no encontrado: $backup_name"
                return 1
            fi

            log_history "Restored backup: $backup_name"
            ;;
    esac
}

# Comando: sf pr (Pull Request / Issue)
create_pr_issue() {
    local action="pr"
    local title=""
    local body=""

    # Parsear argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            pr)
                action="pr"
                shift
                ;;
            issue)
                action="issue"
                shift
                ;;
            --title)
                if [[ -n "$2" ]]; then
                    title="$2"
                    shift 2
                else
                    echo "‚ùå Uso: --title <t√≠tulo>"
                    return 1
                fi
                ;;
            --body)
                if [[ -n "$2" ]]; then
                    body="$2"
                    shift 2
                else
                    echo "‚ùå Uso: --body <descripci√≥n>"
                    return 1
                fi
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Opciones:"
                echo "  pr                 Crear Pull Request (por defecto)"
                echo "  issue              Crear Issue"
                echo "  --title <texto>    T√≠tulo personalizado"
                echo "  --body <texto>     Descripci√≥n personalizada"
                return 1
                ;;
        esac
    done

    get_current_branch

    # Generar t√≠tulo por defecto
    if [[ -z "$title" ]]; then
        case $action in
            pr)
                title="feat: $CURRENT_BRANCH"
                ;;
            issue)
                title="Issue: $CURRENT_BRANCH"
                ;;
        esac
    fi

    # Generar descripci√≥n por defecto
    if [[ -z "$body" ]]; then
        case $action in
            pr)
                body="Pull Request for branch: $CURRENT_BRANCH\n\nChanges:\n$(git log --oneline master.."$CURRENT_BRANCH" 2>/dev/null || echo "New branch")"
                ;;
            issue)
                body="Issue related to branch: $CURRENT_BRANCH"
                ;;
        esac
    fi

    echo "üîó Creando $action..."

    # Verificar si GitHub CLI est√° disponible
    if command -v gh &> /dev/null; then
        echo "‚úÖ GitHub CLI detectado. Creando $action autom√°ticamente..."

        case $action in
            pr)
                gh pr create --title "$title" --body "$body" || { echo "‚ùå Error: Fall√≥ crear PR."; return 1; }
                ;;
            issue)
                gh issue create --title "$title" --body "$body" || { echo "‚ùå Error: Fall√≥ crear issue."; return 1; }
                ;;
        esac

        log_history "Created $action via GitHub CLI: $title"
        echo "‚úÖ $action creado exitosamente."

    else
        echo "‚ö†Ô∏è  GitHub CLI no detectado. Aqu√≠ est√°n las instrucciones manuales:"
        echo ""
        echo "Para crear un $action manualmente:"
        echo ""
        echo "1. Ve a tu repositorio en GitHub/GitLab"
        echo "2. Crea un nuevo $action con estos detalles:"
        echo ""
        echo "T√≠tulo: $title"
        echo "Descripci√≥n:"
        echo "$body"
        echo ""
        echo "Comandos alternativos:"
        echo "- Instala GitHub CLI: https://cli.github.com/"
        echo "- O usa la interfaz web de tu plataforma Git"

        log_history "Generated $action instructions: $title"
    fi
}

# Comando: sf init

# Comando: sf init
init_project() {
    echo "üöÄ Inicializando proyecto sf..."

    # Verificar si se fuerza reinicializaci√≥n ANTES de cualquier an√°lisis
    if [[ "$1" == "--force" ]]; then
        echo "üîÑ Forzando reinicializaci√≥n completa..."
        echo ""
    fi

    # An√°lisis inteligente del estado actual
    local needs_init=false
    local existing_config=""

    if [[ -f ".env" ]]; then
        existing_config+="‚úÖ .env existe\n"
        source .env 2>/dev/null
        if [[ -n "$SHOPIFY_STORE" && -n "$SHOPIFY_THEME_ID" ]]; then
            existing_config+="‚úÖ Variables de entorno configuradas\n"
        else
            existing_config+="‚ö†Ô∏è  Variables de entorno incompletas\n"
            needs_init=true
        fi
    else
        existing_config+="‚ùå .env no existe\n"
        needs_init=true
    fi

    if [[ -x "sf" ]]; then
        existing_config+="‚úÖ Script sf es ejecutable\n"
    else
        existing_config+="‚ùå Script sf no es ejecutable\n"
        needs_init=true
    fi

    if [[ -d ".git" ]]; then
        existing_config+="‚úÖ Repositorio Git inicializado\n"
    else
        existing_config+="‚ùå Repositorio Git no inicializado\n"
        needs_init=true
    fi

    echo "üìä Estado actual del proyecto:"
    echo -e "$existing_config"

    if [[ "$needs_init" == false && "$1" != "--force" ]]; then
        echo ""
        echo "üéâ El proyecto ya est√° completamente inicializado."
        echo "üí° Si quieres reinicializar, ejecuta: sf init --force"
        echo ""
        echo "Para verificar configuraci√≥n: sf status"
        return 0
    fi

    # Verificar confirmaci√≥n (solo si no es --force)
    if [[ "$1" != "--force" ]]; then
        echo ""
        if ! confirm_action "¬øProceder con la inicializaci√≥n?" "y"; then
            echo "üö´ Inicializaci√≥n cancelada."
            return 1
        fi
    fi

    # 1. Verificar dependencias
    echo ""
    echo "üì¶ Verificando dependencias..."
    validate_dependencies

    # 2. Hacer script ejecutable
    echo "üîß Configurando permisos del script..."
    chmod +x sf || { echo "‚ùå Error: No se pudieron configurar permisos."; return 1; }

    # 3. Crear .env si no existe
    if [[ ! -f ".env" ]]; then
        echo "üìù Creando archivo .env..."
        cat > .env << EOF
# Variables de entorno para el proyecto
# Configuraci√≥n de Shopify
SHOPIFY_STORE="tu-tienda.myshopify.com"
SHOPIFY_THEME_ID="123456789"
EOF
        echo "‚úÖ Archivo .env creado. Ed√≠talo con tus valores reales."
    else
        echo "‚úÖ Archivo .env ya existe."
    fi

    # 4. Verificar/inicializar repositorio Git
    if [[ ! -d ".git" ]]; then
        echo "üìö Inicializando repositorio Git..."
        git init || { echo "‚ùå Error: No se pudo inicializar Git."; return 1; }
        git checkout -b master 2>/dev/null || git switch -c master 2>/dev/null || { echo "‚ùå Error: No se pudo crear rama master."; return 1; }
        echo "‚úÖ Repositorio Git inicializado."
    else
        echo "‚úÖ Repositorio Git ya existe."
    fi

    # 5. Configurar alias
    echo "üîó Configurando alias global..."
    local script_path="$(pwd)/sf"
    if ! grep -q "alias sf=" ~/.bashrc 2>/dev/null && ! grep -q "alias sf=" ~/.zshrc 2>/dev/null; then
        echo "alias sf=\"$script_path\"" >> ~/.bashrc
        source ~/.bashrc 2>/dev/null || true
        echo "‚úÖ Alias configurado en ~/.bashrc"
        echo "üí° Reinicia tu terminal o ejecuta: source ~/.bashrc"
    else
        echo "‚úÖ Alias ya configurado."
    fi

    # 6. Crear .gitignore si no existe
    if [[ ! -f ".gitignore" ]]; then
        echo "üìÑ Creando .gitignore b√°sico..."
        cat > .gitignore << EOF
# sf
.env
.sf_history

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/

# Logs
*.log
EOF
        echo "‚úÖ Archivo .gitignore creado."
    fi

    log_history "Project initialized"
    echo ""
    echo "üéâ ¬°Proyecto inicializado exitosamente!"
    echo ""
    echo "üìã Checklist completado:"
    echo "  ‚úÖ Dependencias verificadas"
    echo "  ‚úÖ Script configurado"
    echo "  ‚úÖ Variables de entorno"
    echo "  ‚úÖ Repositorio Git"
    echo "  ‚úÖ Alias global"
    echo "  ‚úÖ .gitignore"
    echo ""
    suggest_next_steps "init"
}

# Comando: sf help
show_help() {
    echo "sf - Shopify Flow CLI"
    echo ""
    echo "Comandos disponibles:"
    echo "  sf init      - Inicializa el proyecto y configura sf"
    echo "  sf start     - Inicia un nuevo flujo de trabajo creando una rama"
    echo "  sf commit    - Confirma cambios en la rama actual"
    echo "  sf publish   - Fusiona rama a master y publica en Shopify"
    echo "  sf sync      - Sincroniza cambios desde Shopify Admin"
    echo "  sf resolve   - Resuelve conflictos y confirma cambios"
    echo "  sf status    - Muestra estado de Git y Shopify"
    echo "  sf dev       - Inicia servidor de desarrollo local"
    echo "  sf finish    - Elimina la rama actual despu√©s de publicar"
    echo "  sf stash     - Guarda cambios locales en stash"
    echo "  sf log       - Muestra historial de acciones"
    echo "  sf diff      - Compara diferencias entre ramas o con Shopify"
    echo "  sf clean     - Limpia ramas merged o antiguas"
    echo "  sf backup    - Gestiona copias de seguridad"
    echo "  sf pr        - Crea Pull Requests o Issues"
    echo "  sf help      - Muestra esta ayuda"
    echo ""
    echo "Flags globales disponibles:"
    echo "  --dry-run    Simula la operaci√≥n sin ejecutarla"
    echo "  --force      Omite confirmaciones y validaciones de seguridad"
    echo "  --verbose    Muestra informaci√≥n detallada"
    echo ""
    echo "Aseg√∫rate de configurar SHOPIFY_STORE y SHOPIFY_THEME_ID."
}

# Comando: sf dev
start_dev_server() {
    validate_env

    echo "üöÄ Iniciando servidor de desarrollo..."
    echo "üéØ Usando configuraci√≥n por defecto de Shopify CLI (tema de desarrollo)"
    echo ""

    # Parsear argumentos PRIMERO
    local test_mode=false
    local port="9292"
    local host="127.0.0.1"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                echo "Uso: sf dev [opciones]"
                echo ""
                echo "Opciones:"
                echo "  --test     Modo informativo de pruebas (sin cambios funcionales)"
                echo "  --port N   Puerto del servidor (default: 9292)"
                echo "  --host IP  Host del servidor (default: 127.0.0.1)"
                echo "  --help     Mostrar esta ayuda"
                return 0
                ;;
            --test)
                test_mode=true
                shift
                ;;
            --port)
                port="$2"
                shift 2
                ;;
            --host)
                host="$2"
                shift 2
                ;;
            *)
                echo "‚ùå Opci√≥n desconocida: $1"
                echo "Usa 'sf dev --help' para ver opciones disponibles."
                return 1
                ;;
        esac
    done

    # Verificar si ya hay un servidor corriendo
    if pgrep -f "shopify theme dev" > /dev/null; then
        echo "‚ö†Ô∏è  Parece que ya hay un servidor de desarrollo corriendo."
        echo "üí° Si quieres detenerlo, usa: pkill -f 'shopify theme dev'"
        echo ""
        if ! confirm_action "¬øIniciar otro servidor de todas formas?" "n"; then
            return 0
        fi
    fi

    # Construir comando
    local cmd="shopify theme dev --port=\"$port\" --host=\"$host\""

    if [[ "$test_mode" == true ]]; then
        echo "üß™ Modo de pruebas activado (desarrollo sin recarga autom√°tica)"
        echo "üí° En modo pruebas, los cambios no se reflejan autom√°ticamente"
    else
        echo "üîÑ Modo desarrollo con recarga autom√°tica"
    fi

    echo "üì° Comando: $cmd"
    echo ""
    echo "üåê Una vez iniciado, podr√°s acceder a:"
    echo "   http://$host:$port"
    echo ""
    echo "üí° Presiona Ctrl+C para detener el servidor"
    echo ""

    # Ejecutar comando
    eval "$cmd"
}

# Funci√≥n principal
main() {
    case "${1:-help}" in
        init) shift; init_project "$@" ;;
        *) 
            load_env
            validate_dependencies

            # Validaciones preventivas inteligentes
            if ! preventive_checks "$1"; then
                return 1
            fi

            # Sugerencias inteligentes
            smart_suggestions "$1"

            case "$1" in
                start) start_branch ;;
                commit) commit_changes ;;
                publish) shift; publish_changes "$@" ;;
                sync) shift; sync_changes "$@" ;;
                resolve) resolve_conflicts ;;
                status) show_status ;;
                finish) finish_branch ;;
                stash) stash_changes ;;
                log) shift; show_log "$@" ;;
                diff) shift; show_diff "$@" ;;
                clean) shift; clean_branches "$@" ;;
                backup) shift; create_backup "$@" ;;
                pr) shift; create_pr_issue pr "$@" ;;
                dev) shift; start_dev_server "$@" ;;
                help|--help|-h) show_help ;;
                *) echo "‚ùå Comando desconocido: $1"; show_help; exit 1 ;;
            esac
            ;;
    esac
}

main "$@"